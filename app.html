<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="app_title">IIT Madras Water Management</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700">
    <link rel="icon" href="IIT_Madras_Logo.ico" type="image/x-icon">
    <link rel="manifest" href="/PADUR_WATER_MANAGEMENT/manifest.json">
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="config.js"></script>
    <script src="translation-manager.js"></script>
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            font-size: 18px;
            text-align: center;
            background-image: url('bg.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            margin: 0;
            padding: 20px;
        }
        h1, h2 { color: #333; font-size: 2.5em; }
        h3 { font-size: 1.8em; }
        .spacer { height: 30px; display: block; margin: 0; }
        
        .language-selector-header {
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            position: relative;
            z-index: 100;
        }
        .language-selector-header label {
            font-weight: bold;
            font-size: 18px;
            margin: 0;
            color: white;
        }
        .language-selector-header select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
        }
        .language-selector-header select option {
            background-color: #007bff;
            color: white;
        }
        .header {
            background-color: rgba(0, 123, 255, 0);
            color: white;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .header h1 {
            color: white;
            margin: 0;
            flex: 1;
            font-size: 2em;
        }
        .back-button, .utility-button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }
        .back-button:hover, .utility-button:hover {
            background-color: #0056b3;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 280px;
            min-height: 200px;
        }
        .card-header {
            font-size: 1.5em;
            font-weight: 600;
            color: #007bff;
            margin-bottom: 15px;
        }
        .value-box {
            font-size: 3em;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        .indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 10px auto;
            border: 2px solid #999;
        }
        .timestamp {
            font-size: 12px;
            color: #999;
            margin-top: 10px;
        }
        
        #chart_container {
            position: relative;
            padding: 0;
            background-color: rgba(249, 249, 999, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 100%;
            height: 500px;
            min-height: 400px;
            box-sizing: border-box;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .individual-chart-container {
            position: relative;
            padding: 0;
            background-color: rgba(249, 249, 249, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 100%;
            height: 500px;
            min-height: 400px;
            box-sizing: border-box;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .individual-chart-wrapper {
            display: none;
        }
        
        .individual-chart-wrapper.multi-sensor-active {
            display: block;
        }
        
        .chart-controls {
            flex-shrink: 0;
            padding: 15px;
            background: #007bff;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        #custom-range-section {
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .custom-range-section-multi {
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        
        #level_chart {
            width: 100% !important;
            height: 100% !important;
            flex: 1 !important;
            min-height: 400px !important;
        }
        
        .sensor-chart {
            width: 100% !important;
            height: 100% !important;
            flex: 1 !important;
            min-height: 400px !important;
        }
        
        @media (max-width: 768px) {
            #chart_container { height: 350px; }
            .chart-controls { padding: 12px; gap: 10px; }
        }
        
        @media (max-width: 550px) {
            body { padding: 8px; font-size: 14px; }
            h1 { font-size: 20px; }
            
            #chart_container { 
                height: auto;
                width: auto;
                margin: 20px 0;
                overflow: hidden;
                max-height: 100%;
            }
            
            .individual-chart-container {
                height: auto !important;
                margin-top: 15px;
            }
            
            .chart-controls {
                flex-direction: column;
                padding: 10px;
            }
            
            .chart-controls > span { width: 100%; margin-bottom: 5px; }
            .chart-controls > select { width: 100%; padding: 10px; }
            .chart-controls > div { width: 100%; flex-direction: column; gap: 8px; }
            
            #custom-range-section {
                padding: 12px;
                margin-top: 10px;
            }
            
            .custom-range-section-multi {
                padding: 12px;
                margin-top: 10px;
            }
            
            #custom-range-section > div,
            .custom-range-section-multi > div {
                flex-direction: column;
                gap: 10px;
            }
            
            #custom-range-section input,
            #custom-range-section button,
            .custom-range-section-multi input,
            .custom-range-section-multi button {
                width: 100%;
                padding: 10px;
            }
        }
        
        @media (max-width: 360px) {
            body { padding: 5px; }
            #chart_container { height: 380px; }
        }
        #devtools-blocker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 999999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #devtools-blocker h1 {
            font-size: 32px;
            color: #ff6b6b;
            margin-bottom: 20px;
        }
        #devtools-blocker p {
            font-size: 18px;
            margin: 10px 0;
        }
    </style>
</head>
<body>

    <!-- DevTools Blocker Overlay -->
    <div id="devtools-blocker">
        <h1>‚ö†Ô∏è Developer Tools Disabled</h1>
        <p>Developer Tools are not allowed on this page.</p>
        <p>Close the DevTools and refresh the page to continue.</p>
    </div>

    <div class="header">
        <button class="back-button" onclick="goBack()" data-i18n="back">‚Üê Back</button>
        <h1 id="pageTitle" data-i18n="water_management">Water Management</h1>
    </div>

    <h2 class="section-header" id="pageTitleHeading" style="color: rgb(0, 89, 255); text-shadow: 0 0 10px rgba(238, 238, 238, 0.8), 0 0 20px rgba(246, 246, 246, 0.6), 0 0 30px rgba(0, 123, 255, 0.4), 2px 2px 4px rgba(0,0,0,0.5); font-size: 3em; margin: 0;">Water Management</h2>
    <h2 class="section-header" data-i18n="water_level_monitoring" id="sectionTitle" style="display: none;">Water Level Monitoring</h2>
    <div class="container" id="sensors-container"></div>
    
    <div id="multi-sensor-charts" style="display: none;"></div>

    <div id="chart_container">
        <div class="chart-controls">
            <span style="font-weight: bold; font-size: 18px;" data-i18n="water_level_history">Water Level History</span>
            <select id="days-selector" style="padding: 8px 12px; border-radius: 3px; border: 1px solid #ccc; background: white; color: #333; font-weight: 600; cursor: pointer;">
                <option value="1" data-i18n="day_1">1 Day</option>
                <option value="2" data-i18n="day_2">2 Days</option>
                <option value="3" data-i18n="day_3">3 Days</option>
                <option value="4" data-i18n="day_4">4 Days</option>
                <option value="5" data-i18n="day_5">5 Days</option>
                <option value="6" data-i18n="day_6">6 Days</option>
                <option value="7" data-i18n="day_7">7 Days</option>
                <option value="custom" data-i18n="custom_range">Custom Range</option>
            </select>
            <div style="display: flex; gap: 10px; align-items: center;">
                <label style="font-size: 14px; font-weight: bold; color: white;" data-i18n="line_color">Line Color</label>
                <input type="color" id="line-color-picker" value="#048ebd" style="width: 50px; height: 40px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
            </div>
        </div>
        <div id="level_chart"></div>
    </div>

    <div id="custom-range-section" style="padding: 15px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; display: none; width: 100%; box-sizing: border-box;">
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center;">
            <div>
                <label style="font-size: 12px; font-weight: bold;" data-i18n="from">From:</label><br>
                <input type="datetime-local" id="custom-start-date" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div>
                <label style="font-size: 12px; font-weight: bold;" data-i18n="to">To:</label><br>
                <input type="datetime-local" id="custom-end-date" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-top: 18px;">
                <button onclick="fetchCustomDateRange()" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: 600;" data-i18n="fetch_data">Fetch Data</button>
            </div>
        </div>
    </div>
    <div class="timestamp" id="chart_update_time" style="text-align: center; margin-top: 10px; color: #666; font-size: 14px;" data-i18n="waiting_for_history">Waiting for history data...</div>

    <script>
        // Disable Developer Tools (F12, Ctrl+Shift+I, Ctrl+Shift+C, Right-click)
        document.addEventListener('keydown', function(e) {
            // F12
            if (e.key === 'F12') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+I (Developer Tools)
            if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+C (Inspect Element)
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+J (Console)
            if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                e.preventDefault();
                return false;
            }
        });

        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        // Detect DevTools opening via console check
        let devtools = { open: false };
        const threshold = 160;
        
        function checkDevTools() {
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;
            
            if (widthThreshold || heightThreshold) {
                if (!devtools.open) {
                    devtools.open = true;
                    showDevToolsBlocker();
                }
            } else {
                if (devtools.open) {
                    devtools.open = false;
                    hideDevToolsBlocker();
                }
            }
        }
        
        function showDevToolsBlocker() {
            const blocker = document.getElementById('devtools-blocker');
            if (blocker) {
                blocker.style.display = 'flex';
            }
        }
        
        function hideDevToolsBlocker() {
            const blocker = document.getElementById('devtools-blocker');
            if (blocker) {
                blocker.style.display = 'none';
            }
        }
        
        // Check every 200ms for DevTools
        setInterval(checkDevTools, 200);
        
        let translationManager;
        
        // Disable console logs (set to false to enable debug logs)
        const DEBUG_MODE = false;
        if (!DEBUG_MODE) {
            console.log = function() {};
            console.error = function() {};
            console.warn = function() {};
            console.info = function() {};
        }
        
        // Initialize Translation Manager FIRST and WAIT for it
        async function initTranslationManager() {
            return new Promise((resolve) => {
                let retries = 0;
                const maxRetries = 100; // 5 seconds at 50ms intervals
                
                const checkInterval = setInterval(() => {
                    retries++;
                    
                    if (typeof TranslationManager !== 'undefined') {
                        clearInterval(checkInterval);
                        translationManager = new TranslationManager();
                        console.log('‚úÖ translationManager instance created');
                        
                        // Load the saved language preference
                        const savedLanguage = localStorage.getItem('preferredLanguage') || 'en';
                        translationManager.loadTranslations(savedLanguage).then((success) => {
                            if (success) {
                                console.log('‚úÖ Translations loaded for:', savedLanguage);
                            } else {
                                console.warn('‚ö†Ô∏è Failed to load translations, using fallback');
                            }
                            resolve();
                        }).catch((err) => {
                            console.error('‚ùå Failed to load translations:', err);
                            resolve(); // Resolve anyway to continue
                        });
                    } else if (retries > maxRetries) {
                        clearInterval(checkInterval);
                        console.error('‚ùå TranslationManager not loaded, creating instance anyway');
                        translationManager = new TranslationManager ? new TranslationManager() : {};
                        resolve(); // Resolve to continue
                    }
                }, 50);
            });
        }

        const urlParams = new URLSearchParams(window.location.search);
        const currentPageId = urlParams.get('page') || 'reservoir';
        const currentPageConfig = appConfig.getPage(currentPageId);
        
        if (!currentPageConfig) {
            document.body.innerHTML = '<h1>Page not found</h1>';
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // WAIT for translation manager to be initialized and ready
            await initTranslationManager();
            
            // Double-check translationManager exists and has translate method
            if (!translationManager || typeof translationManager.translate !== 'function') {
                console.warn('‚ö†Ô∏è translationManager not functional, creating new instance');
                translationManager = new TranslationManager();
                await translationManager.loadTranslations(localStorage.getItem('preferredLanguage') || 'en');
            }
            
            initializePage();
            setTimeout(() => {
                translationManager.applyTranslations();
            }, 100);
        });

        function initializePage() {
            if (!currentPageConfig) return;
            if (!translationManager || typeof translationManager.translate !== 'function') {
                console.error('‚ùå translationManager not ready! Retrying...');
                return setTimeout(initializePage, 100);
            }

            document.title = currentPageConfig.title;
            document.getElementById('pageTitle').textContent = currentPageConfig.displayName;
            const pageTitleHeading = document.getElementById('pageTitleHeading');
            const pageTranslationKey = `page_${currentPageConfig.id}`;
            const translatedPageName = (translationManager && translationManager.translate) ? 
                (translationManager.translate(pageTranslationKey) || currentPageConfig.displayName) : 
                currentPageConfig.displayName;
            pageTitleHeading.textContent = translatedPageName;
            document.getElementById('sectionTitle').textContent = currentPageConfig.title;

            const container = document.getElementById('sensors-container');
            container.innerHTML = '';
            Object.entries(currentPageConfig.sensors).forEach(([sensorId, sensorConfig]) => {
                const sensorTranslationKey = `sensor_${currentPageConfig.id}_${sensorId}`;
                const translatedSensorName = (translationManager && translationManager.translate) ? 
                    (translationManager.translate(sensorTranslationKey) || sensorConfig.displayName) : 
                    sensorConfig.displayName;
                container.innerHTML += `
                    <div class="card">
                        <div class="card-header" data-i18n="${sensorTranslationKey}">${translatedSensorName}</div>
                        <div class="value-box" id="${sensorId}_cm">-- cm</div><br>
                        <div class="value-box" id="${sensorId}_feet">--</div>
                        <div class="timestamp" id="${sensorId}_time">Waiting for updates...</div>
                        <div class="indicator" id="${sensorId}_indicator"></div>
                    </div>
                `;
            });

            updateAllData();
            setInterval(updateAllData, 20000);

            google.charts.load('current', {'packages':['corechart']});
            google.charts.setOnLoadCallback(initializeCharts);
        }

        function goBack() {
            window.location.href = 'index.html';
        }

        function timeAgo(timestamp) {
            const now = new Date();
            const past = new Date(timestamp);
            const diffMs = now - past;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} min ago`;
            return `${diffHours} hour(s) ago`;
        }

        function cmToFeetInches(cm) {
            const inches = cm / 2.54;
            const feet = Math.floor(inches / 12);
            const remainingInches = Math.round(inches % 12);
            return `${feet} ft ${remainingInches} in`;
        }

        function updateIndicator(sensor, value) {
            const indicator = document.getElementById(sensor + '_indicator');
            if (!indicator) return;
            const limits = currentPageConfig.sensors[sensor].limits;
            if (!limits) return;
            if (value <= limits.danger) {
                indicator.style.background = 'red';
            } else if (value <= limits.warning) {
                indicator.style.background = 'yellow';
            } else {
                indicator.style.background = 'green';
            }
        }

        async function fetchThingSpeakData(sensorId) {
            const sensorConfig = currentPageConfig.sensors[sensorId];
            if (!sensorConfig) return;

            const fieldNumber = sensorConfig.field.replace('field', '');
            const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&results=20&fields=${fieldNumber}`;
            try {
                const response = await fetch(url, { method: 'GET', cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                if (!data || !data.feeds || data.feeds.length === 0) return;

                let lastValidValue = '--';
                let lastUpdated = 'No updates';
                for (let i = data.feeds.length - 1; i >= 0; i--) {
                    let rawValue = data.feeds[i][sensorConfig.field];
                    if (rawValue === null || rawValue === undefined || rawValue === '') continue;
                    let value = parseFloat(rawValue);
                    if (!isNaN(value)) {
                        lastValidValue = value;
                        lastUpdated = data.feeds[i].created_at;
                        break;
                    }
                }

                if (lastValidValue !== '--') {
                    const formattedValue = sensorConfig.isInteger ? Math.round(lastValidValue) : parseFloat(lastValidValue).toFixed(2);
                    const cmElement = document.getElementById(sensorId + '_cm');
                    const feetElement = document.getElementById(sensorId + '_feet');
                    const timeElement = document.getElementById(sensorId + '_time');

                    if (cmElement) cmElement.innerText = `${formattedValue} cm`;
                    if (feetElement) feetElement.innerText = cmToFeetInches(formattedValue);
                    if (timeElement) timeElement.innerText = 'Updated ' + timeAgo(lastUpdated);

                    updateIndicator(sensorId, formattedValue);
                    console.log(`[DATA] ${sensorId}: ${formattedValue} cm`);
                }
            } catch (error) {
                console.error(`Error fetching data for ${sensorId}:`, error);
            }
        }

        function updateAllData() {
            Object.keys(currentPageConfig.sensors).forEach(sensor => fetchThingSpeakData(sensor));
        }

        let Chart;
        let ChartData;
        let isCustomRange = false;
        let Charts = {}; // Map to store chart objects for each sensor
        let ChartsData = {}; // Map to store data tables for each sensor
        let isMultiSensorMode = false;

        function initializeCharts() {
            const sensorKeys = Object.keys(currentPageConfig.sensors);
            isMultiSensorMode = sensorKeys.length > 1;
            
            if (isMultiSensorMode) {
                // Show multi-sensor charts
                document.getElementById('chart_container').style.display = 'none';
                document.getElementById('multi-sensor-charts').style.display = 'block';
                
                // Create a chart for each sensor
                sensorKeys.forEach(sensorId => {
                    const sensorConfig = currentPageConfig.sensors[sensorId];
                    const sensorTranslationKey = `sensor_${currentPageConfig.id}_${sensorId}`;
                    const translatedSensorName = (translationManager && translationManager.translate) ? 
                        (translationManager.translate(sensorTranslationKey) || sensorConfig.displayName) : 
                        sensorConfig.displayName;
                    
                    // Create chart container HTML
                    const chartHtml = `
                        <div class="individual-chart-wrapper multi-sensor-active" id="${sensorId}_chart_wrapper">
                            <div class="individual-chart-container">
                                <div class="chart-controls">
                                    <span style="font-weight: bold; font-size: 18px;" data-i18n="sensor_${currentPageConfig.id}_${sensorId}">${translatedSensorName}</span>
                                    <select class="days-selector-multi" data-sensorid="${sensorId}" style="padding: 8px 12px; border-radius: 3px; border: 1px solid #ccc; background: white; color: #333; font-weight: 600; cursor: pointer;">
                                        <option value="1" data-i18n="day_1">1 Day</option>
                                        <option value="2" data-i18n="day_2">2 Days</option>
                                        <option value="3" data-i18n="day_3">3 Days</option>
                                        <option value="4" data-i18n="day_4">4 Days</option>
                                        <option value="5" data-i18n="day_5">5 Days</option>
                                        <option value="6" data-i18n="day_6">6 Days</option>
                                        <option value="7" data-i18n="day_7">7 Days</option>
                                        <option value="custom" data-i18n="custom_range">Custom Range</option>
                                    </select>
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <label style="font-size: 14px; font-weight: bold; color: white;" data-i18n="line_color">Line Color</label>
                                        <input type="color" class="line-color-picker-multi" data-sensorid="${sensorId}" value="#048ebd" style="width: 50px; height: 40px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
                                    </div>
                                </div>
                                <div id="${sensorId}_chart" class="sensor-chart"></div>
                            </div>
                            <div id="${sensorId}_custom_range_section" class="custom-range-section-multi" style="padding: 15px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; display: none; width: 100%; box-sizing: border-box;">
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center;">
                                    <div>
                                        <label style="font-size: 12px; font-weight: bold;" data-i18n="from">From:</label><br>
                                        <input type="datetime-local" class="custom-start-date-multi" data-sensorid="${sensorId}" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
                                    </div>
                                    <div>
                                        <label style="font-size: 12px; font-weight: bold;" data-i18n="to">To:</label><br>
                                        <input type="datetime-local" class="custom-end-date-multi" data-sensorid="${sensorId}" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
                                    </div>
                                    <div style="margin-top: 18px;">
                                        <button onclick="fetchCustomDateRangeMulti('${sensorId}')" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: 600;" data-i18n="fetch_data">Fetch Data</button>
                                    </div>
                                </div>
                            </div>
                            <div class="timestamp" id="${sensorId}_chart_update_time" style="text-align: center; margin-top: 10px; color: #666; font-size: 14px;" data-i18n="waiting_for_history">Waiting for history data...</div>
                        </div>
                    `;
                    
                    document.getElementById('multi-sensor-charts').innerHTML += chartHtml;
                });
                
                // Initialize data tables and charts for each sensor
                sensorKeys.forEach(sensorId => {
                    ChartsData[sensorId] = new google.visualization.DataTable();
                    ChartsData[sensorId].addColumn('datetime', 'Time');
                    ChartsData[sensorId].addColumn('number', 'Water Level (cm)');
                    ChartsData[sensorId].addColumn({type: 'string', role: 'tooltip'});
                    
                    Charts[sensorId] = new google.visualization.LineChart(document.getElementById(sensorId + '_chart'));
                    
                    // Add event listeners for each sensor
                    const daysSelector = document.querySelector(`select.days-selector-multi[data-sensorid="${sensorId}"]`);
                    if (daysSelector) {
                        daysSelector.addEventListener('change', function() {
                            if (this.value === 'custom') {
                                document.getElementById(sensorId + '_custom_range_section').style.display = 'block';
                            } else {
                                document.getElementById(sensorId + '_custom_range_section').style.display = 'none';
                                fetchHistoricalDataMulti(sensorId);
                            }
                        });
                    }
                    
                    const colorPicker = document.querySelector(`input.line-color-picker-multi[data-sensorid="${sensorId}"]`);
                    if (colorPicker) {
                        colorPicker.addEventListener('change', function() {
                            localStorage.setItem(`graphLineColor_${sensorId}`, this.value);
                            fetchHistoricalDataMulti(sensorId);
                        });
                    }
                    
                    // Load initial data
                    fetchHistoricalDataMulti(sensorId);
                });
            } else {
                // Single sensor mode - use original logic
                ChartData = new google.visualization.DataTable();
                ChartData.addColumn('datetime', 'Time');
                ChartData.addColumn('number', 'Water Level (cm)');
                ChartData.addColumn({type: 'string', role: 'tooltip'});

                Chart = new google.visualization.LineChart(document.getElementById('level_chart'));
                
                document.getElementById('days-selector').addEventListener('change', function() {
                    if (this.value === 'custom') {
                        document.getElementById('custom-range-section').style.display = 'block';
                        const savedCustomRange = localStorage.getItem('customDateRange');
                        if (savedCustomRange) {
                            const ranges = JSON.parse(savedCustomRange);
                            document.getElementById('custom-start-date').value = ranges.start;
                            document.getElementById('custom-end-date').value = ranges.end;
                            fetchCustomDateRange();
                        }
                    } else {
                        document.getElementById('custom-range-section').style.display = 'none';
                        isCustomRange = false;
                        localStorage.removeItem('customDateRange');
                        fetchHistoricalData();
                    }
                });
                
                const colorPicker = document.getElementById('line-color-picker');
                if (colorPicker) {
                    colorPicker.addEventListener('change', function() {
                        localStorage.setItem('graphLineColor', this.value);
                        if (isCustomRange) {
                            fetchCustomDateRange();
                        } else {
                            fetchHistoricalData();
                        }
                    });
                }
                
                const savedCustomRange = localStorage.getItem('customDateRange');
                if (savedCustomRange) {
                    const ranges = JSON.parse(savedCustomRange);
                    document.getElementById('custom-start-date').value = ranges.start;
                    document.getElementById('custom-end-date').value = ranges.end;
                    document.getElementById('days-selector').value = 'custom';
                    document.getElementById('custom-range-section').style.display = 'block';
                    isCustomRange = true;
                    fetchCustomDateRange();
                } else {
                    fetchHistoricalData();
                }
            }
        }
        
        function getResponsiveChartOptions(title, selectedDays = 1) {
            const isMobile = window.innerWidth <= 768;
            const dayText = selectedDays === 1 ? 'Day' : 'Days';
            const lineColor = localStorage.getItem('graphLineColor') || '#048ebd';
            
            return {
                title: title,
                titleTextStyle: { color: '#333', fontSize: isMobile ? 12 : 14, bold: true },
                legend: { position: 'bottom' },
                hAxis: { title: 'Time', format: selectedDays === 1 ? 'HH:mm' : 'dd/MM HH:mm', gridlines: { count: isMobile ? 4 : 8 }, titleTextStyle: { fontSize: isMobile ? 10 : 12 }, textStyle: { fontSize: isMobile ? 9 : 11 } },
                vAxis: { title: 'Water Level (cm)', minValue: 0, titleTextStyle: { fontSize: isMobile ? 10 : 12 }, textStyle: { fontSize: isMobile ? 9 : 11 } },
                colors: [lineColor],
                lineWidth: 3,
                pointSize: 5,
                chartArea: isMobile ? { left: 40, top: 30, width: '92%', height: '70%' } : { left: 50, top: 35, width: '95%', height: '75%' },
                animation: { duration: 1000, easing: 'out' }
            };
        }

        
        async function fetchHistoricalDataMulti(sensorId) {
            try {
                const sensorConfig = currentPageConfig.sensors[sensorId];
                const daysSelector = document.querySelector(`select.days-selector-multi[data-sensorid="${sensorId}"]`);
                const selectedDays = parseInt(daysSelector ? daysSelector.value : 1) || 1;
                
                console.log(`üìä Fetching chart data for sensor ${sensorId}:`, sensorConfig);
                
                const endDate = new Date();
                const startDate = new Date(endDate.getTime() - (selectedDays * 24 * 60 * 60 * 1000));
                
                const startStr = `${startDate.getUTCFullYear()}-${(startDate.getUTCMonth()+1).toString().padStart(2, '0')}-${startDate.getUTCDate().toString().padStart(2, '0')}%20${startDate.getUTCHours().toString().padStart(2, '0')}:${startDate.getUTCMinutes().toString().padStart(2, '0')}:${startDate.getUTCSeconds().toString().padStart(2, '0')}`;
                const endStr = `${endDate.getUTCFullYear()}-${(endDate.getUTCMonth()+1).toString().padStart(2, '0')}-${endDate.getUTCDate().toString().padStart(2, '0')}%20${endDate.getUTCHours().toString().padStart(2, '0')}:${endDate.getUTCMinutes().toString().padStart(2, '0')}:${endDate.getUTCSeconds().toString().padStart(2, '0')}`;
                
                const fieldNumber = sensorConfig.field.replace('field', '');
                const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000&fields=${fieldNumber}`;
                
                const response = await fetch(url, { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                if (!data || !data.feeds || data.feeds.length === 0) {
                    const dayText = selectedDays === 1 ? 'Day' : 'Days';
                    document.getElementById(`${sensorId}_chart_update_time`).innerText = `No data available in the last ${selectedDays} ${dayText}`;
                    ChartsData[sensorId].removeRows(0, ChartsData[sensorId].getNumberOfRows());
                    const sensorName = currentPageConfig.sensors[sensorId].displayName;
                    Charts[sensorId].draw(ChartsData[sensorId], getResponsiveChartOptions(`${sensorName} - No Data`, selectedDays));
                    return;
                }
                
                const dayText = selectedDays === 1 ? 'Day' : 'Days';
                const Rows = [];
                
                data.feeds.forEach(feed => {
                    const date = new Date(feed.created_at);
                    const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                    if (Value !== null) {
                        const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                        Rows.push([date, Value, Tooltip]);
                    }
                });
                
                console.log(`üìà Chart rows created for ${sensorId}:`, Rows.length);
                
                ChartsData[sensorId].removeRows(0, ChartsData[sensorId].getNumberOfRows());
                ChartsData[sensorId].addRows(Rows);
                
                const sensorName = currentPageConfig.sensors[sensorId].displayName;
                const Options = getResponsiveChartOptions(`${sensorName} - Water Level History`, selectedDays);
                // Apply custom color if set
                const customColor = localStorage.getItem(`graphLineColor_${sensorId}`);
                if (customColor) {
                    Options.colors = [customColor];
                }
                Charts[sensorId].draw(ChartsData[sensorId], Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById(`${sensorId}_chart_update_time`).innerText = `Updated: ${currentTime} ‚Ä¢ ${Rows.length} points ‚Ä¢ ${selectedDays} ${dayText}`;
                    
            } catch (error) {
                console.error(`‚ùå Error fetching historical data for ${sensorId}:`, error);
                document.getElementById(`${sensorId}_chart_update_time`).innerText = `Error: ${error.message}`;
            }
        }
        
        async function fetchCustomDateRangeMulti(sensorId) {
            const startInput = document.querySelector(`input.custom-start-date-multi[data-sensorid="${sensorId}"]`).value;
            const endInput = document.querySelector(`input.custom-end-date-multi[data-sensorid="${sensorId}"]`).value;
            
            if (!startInput || !endInput) {
                alert('Please select both start and end dates');
                return;
            }
            
            try {
                document.getElementById(`${sensorId}_chart_update_time`).innerText = 'Fetching data...';
                
                const sensorConfig = currentPageConfig.sensors[sensorId];
                const startDate = new Date(startInput);
                const endDate = new Date(endInput);
                
                if (startDate >= endDate) {
                    alert('Start date must be before end date');
                    return;
                }
                
                let allRows = [];
                let currentStart = new Date(startDate);
                
                while (currentStart < endDate) {
                    const chunkEnd = new Date(currentStart.getTime() + (7 * 24 * 60 * 60 * 1000));
                    const actualEnd = chunkEnd < endDate ? chunkEnd : endDate;
                    
                    const startStr = `${currentStart.getUTCFullYear()}-${(currentStart.getUTCMonth()+1).toString().padStart(2, '0')}-${currentStart.getUTCDate().toString().padStart(2, '0')}%20${currentStart.getUTCHours().toString().padStart(2, '0')}:${currentStart.getUTCMinutes().toString().padStart(2, '0')}:${currentStart.getUTCSeconds().toString().padStart(2, '0')}`;
                    const endStr = `${actualEnd.getUTCFullYear()}-${(actualEnd.getUTCMonth()+1).toString().padStart(2, '0')}-${actualEnd.getUTCDate().toString().padStart(2, '0')}%20${actualEnd.getUTCHours().toString().padStart(2, '0')}:${actualEnd.getUTCMinutes().toString().padStart(2, '0')}:${actualEnd.getUTCSeconds().toString().padStart(2, '0')}`;
                    
                    const fieldNumber = sensorConfig.field.replace('field', '');
                    const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000&fields=${fieldNumber}`;
                    
                    const response = await fetch(url, { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    
                    const data = await response.json();
                    
                    if (data && data.feeds && data.feeds.length > 0) {
                        data.feeds.forEach(feed => {
                            const date = new Date(feed.created_at);
                            const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                            if (Value !== null) {
                                const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                                allRows.push([date, Value, Tooltip]);
                            }
                        });
                    }
                    
                    currentStart = new Date(actualEnd.getTime() + 1000);
                }
                
                const uniqueRows = Array.from(new Set(allRows.map(r => r[0].getTime())))
                    .map(time => allRows.find(r => r[0].getTime() === time))
                    .sort((a, b) => a[0] - b[0]);
                
                if (uniqueRows.length === 0) {
                    document.getElementById(`${sensorId}_chart_update_time`).innerText = 'No data found';
                    return;
                }
                
                ChartsData[sensorId].removeRows(0, ChartsData[sensorId].getNumberOfRows());
                ChartsData[sensorId].addRows(uniqueRows);
                
                const sensorName = currentPageConfig.sensors[sensorId].displayName;
                const Options = getResponsiveChartOptions(`${sensorName} - Custom Range`, 1);
                // Apply custom color if set
                const customColor = localStorage.getItem(`graphLineColor_${sensorId}`);
                if (customColor) {
                    Options.colors = [customColor];
                }
                Charts[sensorId].draw(ChartsData[sensorId], Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById(`${sensorId}_chart_update_time`).innerText = 
                    `Updated: ${currentTime} ‚Ä¢ ${uniqueRows.length} points`;
                    
            } catch (error) {
                console.error(`Error for ${sensorId}:`, error);
                document.getElementById(`${sensorId}_chart_update_time`).innerText = `Error: ${error.message}`;
            }
        }
        
        async function fetchHistoricalData() {
            try {
                const firstSensor = Object.keys(currentPageConfig.sensors)[0];
                const sensorConfig = currentPageConfig.sensors[firstSensor];
                const selectedDays = parseInt(document.getElementById('days-selector').value) || 1;
                
                console.log('üìä Fetching chart data for sensor:', firstSensor, sensorConfig);
                
                const endDate = new Date();
                const startDate = new Date(endDate.getTime() - (selectedDays * 24 * 60 * 60 * 1000));
                
                const startStr = `${startDate.getUTCFullYear()}-${(startDate.getUTCMonth()+1).toString().padStart(2, '0')}-${startDate.getUTCDate().toString().padStart(2, '0')}%20${startDate.getUTCHours().toString().padStart(2, '0')}:${startDate.getUTCMinutes().toString().padStart(2, '0')}:${startDate.getUTCSeconds().toString().padStart(2, '0')}`;
                const endStr = `${endDate.getUTCFullYear()}-${(endDate.getUTCMonth()+1).toString().padStart(2, '0')}-${endDate.getUTCDate().toString().padStart(2, '0')}%20${endDate.getUTCHours().toString().padStart(2, '0')}:${endDate.getUTCMinutes().toString().padStart(2, '0')}:${endDate.getUTCSeconds().toString().padStart(2, '0')}`;
                
                const fieldNumber = sensorConfig.field.replace('field', '');
                const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000&fields=${fieldNumber}`;
                
                console.log('üìç Request URL:', url);
                
                const response = await fetch(url, { cache: 'no-cache' });
                console.log('üì° Response status:', response.status);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                console.log('üì¶ Data received:', data);
                
                if (!data || !data.feeds || data.feeds.length === 0) {
                    const dayText = selectedDays === 1 ? 'Day' : 'Days';
                    document.getElementById('chart_update_time').innerText = `No data available in the last ${selectedDays} ${dayText}`;
                    ChartData.removeRows(0, ChartData.getNumberOfRows());
                    Chart.draw(ChartData, getResponsiveChartOptions(`${currentPageConfig.displayName} - No Data`, selectedDays));
                    return;
                }
                
                const dayText = selectedDays === 1 ? 'Day' : 'Days';
                const Rows = [];
                
                console.log('üîç First feed sample:', data.feeds[0]);
                console.log('üîç Looking for field number:', fieldNumber);
                console.log('üîç First feed field value:', data.feeds[0][fieldNumber]);
                
                data.feeds.forEach(feed => {
                    const date = new Date(feed.created_at);
                    const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                    if (Value !== null) {
                        const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                        Rows.push([date, Value, Tooltip]);
                    }
                });
                
                console.log('üìà Chart rows created:', Rows.length);
                
                ChartData.removeRows(0, ChartData.getNumberOfRows());
                ChartData.addRows(Rows);
                
                const Options = getResponsiveChartOptions(`${currentPageConfig.displayName} - Water Level History`, selectedDays);
                Chart.draw(ChartData, Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById('chart_update_time').innerText = `Updated: ${currentTime} ‚Ä¢ ${Rows.length} points ‚Ä¢ ${selectedDays} ${dayText}`;
                    
            } catch (error) {
                console.error("‚ùå Error fetching historical data:", error);
                document.getElementById('chart_update_time').innerText = `Error: ${error.message}`;
            }
        }
        
        async function fetchCustomDateRange() {
            const startInput = document.getElementById('custom-start-date').value;
            const endInput = document.getElementById('custom-end-date').value;
            
            if (!startInput || !endInput) {
                alert('Please select both start and end dates');
                return;
            }
            
            try {
                document.getElementById('chart_update_time').innerText = 'Fetching data...';
                
                const firstSensor = Object.keys(currentPageConfig.sensors)[0];
                const sensorConfig = currentPageConfig.sensors[firstSensor];
                const startDate = new Date(startInput);
                const endDate = new Date(endInput);
                
                if (startDate >= endDate) {
                    alert('Start date must be before end date');
                    return;
                }
                
                let allRows = [];
                let currentStart = new Date(startDate);
                
                while (currentStart < endDate) {
                    const chunkEnd = new Date(currentStart.getTime() + (7 * 24 * 60 * 60 * 1000));
                    const actualEnd = chunkEnd < endDate ? chunkEnd : endDate;
                    
                    const startStr = `${currentStart.getUTCFullYear()}-${(currentStart.getUTCMonth()+1).toString().padStart(2, '0')}-${currentStart.getUTCDate().toString().padStart(2, '0')}%20${currentStart.getUTCHours().toString().padStart(2, '0')}:${currentStart.getUTCMinutes().toString().padStart(2, '0')}:${currentStart.getUTCSeconds().toString().padStart(2, '0')}`;
                    const endStr = `${actualEnd.getUTCFullYear()}-${(actualEnd.getUTCMonth()+1).toString().padStart(2, '0')}-${actualEnd.getUTCDate().toString().padStart(2, '0')}%20${actualEnd.getUTCHours().toString().padStart(2, '0')}:${actualEnd.getUTCMinutes().toString().padStart(2, '0')}:${actualEnd.getUTCSeconds().toString().padStart(2, '0')}`;
                    
                    const fieldNumber = sensorConfig.field.replace('field', '');
                    const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000&fields=${fieldNumber}`;
                    
                    const response = await fetch(url, { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    
                    const data = await response.json();
                    
                    if (data && data.feeds && data.feeds.length > 0) {
                        data.feeds.forEach(feed => {
                            const date = new Date(feed.created_at);
                            const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                            if (Value !== null) {
                                const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                                allRows.push([date, Value, Tooltip]);
                            }
                        });
                    }
                    
                    currentStart = new Date(actualEnd.getTime() + 1000);
                }
                
                const uniqueRows = Array.from(new Set(allRows.map(r => r[0].getTime())))
                    .map(time => allRows.find(r => r[0].getTime() === time))
                    .sort((a, b) => a[0] - b[0]);
                
                if (uniqueRows.length === 0) {
                    document.getElementById('chart_update_time').innerText = 'No data found';
                    return;
                }
                
                localStorage.setItem('customDateRange', JSON.stringify({
                    start: startInput,
                    end: endInput
                }));
                isCustomRange = true;
                
                ChartData.removeRows(0, ChartData.getNumberOfRows());
                ChartData.addRows(uniqueRows);
                
                const Options = getResponsiveChartOptions(`${currentPageConfig.displayName} - Custom Range`, 1);
                Chart.draw(ChartData, Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById('chart_update_time').innerText = 
                    `Updated: ${currentTime} ‚Ä¢ ${uniqueRows.length} points`;
                    
            } catch (error) {
                console.error("Error:", error);
                document.getElementById('chart_update_time').innerText = `Error: ${error.message}`;
            }
        }
    </script>
</body>
</html>
