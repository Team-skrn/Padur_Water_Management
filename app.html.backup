<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="app_title">IIT Madras Water Management</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700">
    <link rel="icon" href="IIT_Madras_Logo.ico" type="image/x-icon">
    <link rel="manifest" href="/IITM-LVL-DSPLY-RT-MON/manifest.json">
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="config.js"></script>
    <script src="translation-manager.js"></script>
    <script>
        // ✅ Initialize Translation Manager
        const translationManager = new TranslationManager();
    </script>
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            font-size: 18px;
            text-align: center;
            background-image: url('IITM_bg.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            margin: 0;
            padding: 20px;
        }
        h1, h2 { color: #333; font-size: 2.5em; }
        h3 { font-size: 1.8em; }
        .spacer { height: 30px; display: block; margin: 0; }
        
        .language-selector-header {
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            position: relative;
            z-index: 100;
        }
        .language-selector-header label {
            font-weight: bold;
            font-size: 18px;
            margin: 0;
            color: white;
        }
        .language-selector-header select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
        }
        .language-selector-header select option {
            background-color: #007bff;
            color: white;
        }
        .header {
            background-color: transparent;
            color: white;
            padding: 10px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 15px;
        }
        .header h1 {
            color: white;
            margin: 0;
            flex: 1;
            font-size: 2em;
        }
        .back-button, .utility-button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }
        .back-button:hover, .utility-button:hover {
            background-color: #0056b3;
        }
        .utility-button {
            background-color: #007bff;
            padding: 8px 16px;
        }
        .utility-button:hover {
            background-color: #0056b3;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 280px;
            min-height: 200px;
        }
        .card-header {
            font-size: 1.5em;
            font-weight: 600;
            color: #007bff;
            margin-bottom: 15px;
        }
        .value-box {
            font-size: 3em;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        .indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 10px auto;
            border: 2px solid #999;
        }
        .timestamp {
            font-size: 12px;
            color: #999;
            margin-top: 10px;
        }
        
        #chart_container {
            position: relative;
            padding: 0;
            background-color: rgba(249, 249, 249, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 100%;
            height: 400px;
            min-height: 300px;
            box-sizing: border-box;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chart-controls {
            flex-shrink: 0;
            padding: 15px;
            background: #007bff;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            width: 1%;
            box-sizing: border-box;
        }
        
        #custom-range-section {
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        #level_chart {
            width: 100% !important;
            height: 100% !important;
            flex: 1 !important;
            min-height: 250px !important;
        }
        
        /* Modal Styles */
        .threshold-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1999;
        }
        .threshold-overlay.active { display: block; }
        
        .threshold-settings {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .threshold-settings.active { display: block; }
        .threshold-settings h3 { margin-top: 0; color: #333; }
        .threshold-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .threshold-group h4 { margin: 0 0 10px 0; color: #007bff; }
        .threshold-toggle-row {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .threshold-toggle-row input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        .threshold-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        .threshold-input label { font-weight: bold; min-width: 80px; color: #333; }
        .threshold-input input {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            flex: 1;
            max-width: 150px;
        }
        .btn-save, .btn-cancel {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
        }
        .btn-save {
            background-color: #28a745;
            color: white;
        }
        .btn-save:hover { background-color: #218838; }
        .btn-cancel {
            background-color: #6c757d;
            color: white;
        }
        .btn-cancel:hover { background-color: #5a6268; }
        
        /* RESPONSIVE: Tablets */
        @media (max-width: 768px) {
            #chart_container { height: 350px; }
            .chart-controls { padding: 12px; gap: 10px; }
        }
        
        /* RESPONSIVE: Phones */
        @media (max-width: 550px) {
            body { padding: 8px; font-size: 14px; }
            h1 { font-size: 20px; }
            
            #chart_container { 
                height: auto;
                width: auto;
                margin: 20px 0;
                overflow: hidden;
                max-height: 100%;
            }
            
            .chart-controls {
                flex-direction: column;
                padding: 10px;
            }
            
            .chart-controls > span { width: 100%; margin-bottom: 5px; }
            .chart-controls > select { width: 100%; padding: 10px; }
            .chart-controls > div { width: 100%; flex-direction: column; gap: 8px; }
            
            #custom-range-section {
                padding: 12px;
                margin-top: 10px;
            }
            
            #custom-range-section > div {
                flex-direction: column;
                gap: 10px;
            }
            
            #custom-range-section input,
            #custom-range-section button {
                width: 100%;
                padding: 10px;
            }
        }
        
        /* RESPONSIVE: Small Phones */
        @media (max-width: 360px) {
            body { padding: 5px; }
            #chart_container { height: 380px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <button class="back-button" onclick="goBack()" data-i18n="back">← Back</button>
        <h1 id="pageTitle" data-i18n="water_management" style="display: none;">Water Management</h1>
        <!-- THRESHOLD SETTINGS DISABLED: Alert Settings button removed from UI
        <button class="utility-button" onclick="openThresholdSettings()" style="background-color: #007bff;" title="Set alert thresholds">⚙️ Alert Settings</button>
        -->
    </div>

    <!-- THRESHOLD SETTINGS MODAL DISABLED: Entire threshold modal hidden
    <div class="threshold-overlay" id="thresholdOverlay" onclick="closeThresholdSettings()"></div>
    <div class="threshold-settings" id="thresholdSettings">
        <span onclick="closeThresholdSettings()" style="cursor: pointer; font-size: 24px; float: right;">&times;</span>
        <h3>⚙️ Alert Threshold Settings</h3>
        <p>Set minimum and maximum water level limits.</p>
        <div id="sensorsContainer"></div>
        <button class="btn-save" onclick="saveThresholdSettings()">✅ Save Settings</button>
        <button class="btn-cancel" onclick="closeThresholdSettings()">❌ Cancel</button>
    </div>
    -->

    <!-- Sensors Section -->
    <h2 class="section-header" data-i18n="water_level_monitoring" id="sectionTitle">Water Level Monitoring</h2>
    <div class="container" id="sensors-container">
        <!-- Dynamically populated -->
    </div>

    <!-- Chart with Controls -->
    <div id="chart_container">
        <div class="chart-controls" style="padding: 15px; background: #007bff; color: white; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; width: 100%; box-sizing: border-box;">
            <span style="font-weight: bold; font-size: 18px;" data-i18n="water_level_history">Water Level History</span>
            <select id="days-selector" style="padding: 8px 12px; border-radius: 3px; border: 1px solid #ccc; background: white; color: #333; font-weight: 600; cursor: pointer;">
                <option value="1" data-i18n="day_1">1 Day</option>
                <option value="2" data-i18n="day_2">2 Days</option>
                <option value="3" data-i18n="day_3">3 Days</option>
                <option value="4" data-i18n="day_4">4 Days</option>
                <option value="5" data-i18n="day_5">5 Days</option>
                <option value="6" data-i18n="day_6">6 Days</option>
                <option value="7" data-i18n="day_7">7 Days</option>
                <option value="custom" data-i18n="custom_range">Custom Range</option>
            </select>
            <div style="display: flex; gap: 10px; align-items: center;">
                <label style="font-size: 14px; font-weight: bold; color: white;" data-i18n="line_color">Line Color</label>
                <input type="color" id="line-color-picker" value="#048ebd" style="width: 50px; height: 40px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;">
            </div>
        </div>
        <div id="level_chart"></div>
    </div>

    <!-- Custom Date Range Section - MOVED OUTSIDE CHART CONTAINER -->
    <div id="custom-range-section" style="padding: 15px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; display: none; width: 100%; box-sizing: border-box;">
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: center;">
            <div>
                <label style="font-size: 12px; font-weight: bold;" data-i18n="from">From:</label><br>
                <input type="datetime-local" id="custom-start-date" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div>
                <label style="font-size: 12px; font-weight: bold;" data-i18n="to">To:</label><br>
                <input type="datetime-local" id="custom-end-date" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px;">
            </div>
            <div style="margin-top: 18px;">
                <button onclick="fetchCustomDateRange()" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: 600;" data-i18n="fetch_data">Fetch Data</button>
            </div>
        </div>
    </div>
    <div class="timestamp" id="chart_update_time" style="text-align: center; margin-top: 10px; color: #666; font-size: 14px;" data-i18n="waiting_for_history">Waiting for history data...</div>

    <script>
        // ✅ Get current page from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const currentPageId = urlParams.get('page') || 'reservoir';
        const currentPageConfig = appConfig.getPage(currentPageId);
        
        // ✅ Hide sensitive data from console
        Object.defineProperty(appConfig, 'pages', {
            enumerable: false,
            configurable: false,
            writable: false
        });

        // ✅ Store config in localStorage for Service Worker background monitoring
        try {
            localStorage.setItem('appConfig', JSON.stringify(appConfig));
            console.log('✅ Config stored for background monitoring');
        } catch (e) {
            console.warn('⚠️ Could not store config:', e);
        }

        if (!currentPageConfig) {
            document.body.innerHTML = '<h1>❌ Page not found</h1>';
        }

        // ✅ Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
            loadThresholdSettings();
            // Apply translations after page content is generated
            setTimeout(() => {
                translationManager.applyTranslations();
            }, 100);
        });

        function initializePage() {
            if (!currentPageConfig) return;

            // Set page title
            document.title = currentPageConfig.title;
            
            // Use translation key for page name (e.g., page_main_sump)
            const pageTranslationKey = `page_${currentPageConfig.id}`;
            const translatedPageName = translationManager.translate(pageTranslationKey) || currentPageConfig.displayName;
            
            document.getElementById('pageTitle').textContent = translatedPageName;
            document.getElementById('pageTitle').setAttribute('data-i18n', pageTranslationKey);
            document.getElementById('sectionTitle').textContent = translatedPageName;
            document.getElementById('sectionTitle').setAttribute('data-i18n', pageTranslationKey);

            // Generate sensor cards
            const container = document.getElementById('sensors-container');
            container.innerHTML = '';
            Object.entries(currentPageConfig.sensors).forEach(([sensorId, sensorConfig]) => {
                const sensorTranslationKey = `sensor_${currentPageConfig.id}_${sensorId}`;
                const translatedSensorName = translationManager.translate(sensorTranslationKey) || sensorConfig.displayName;
                container.innerHTML += `
                    <div class="card">
                        <div class="card-header" data-i18n="${sensorTranslationKey}">${translatedSensorName}</div>
                        <div class="value-box" id="${sensorId}_cm">-- cm</div><br>
                        <div class="value-box" id="${sensorId}_feet">--</div>
                        <div class="timestamp" id="${sensorId}_time">Waiting for updates...</div>
                        <div class="indicator" id="${sensorId}_indicator"></div>
                    </div>
                `;
            });

            // THRESHOLD SETTINGS DISABLED: Modal generation code commented out
            /*
            const sensorsContainer = document.getElementById('sensorsContainer');
            sensorsContainer.innerHTML = '';
            Object.entries(currentPageConfig.sensors).forEach(([sensorId, sensorConfig]) => {
                sensorsContainer.innerHTML += `
                    <div class="threshold-group">
                        <h4>${sensorConfig.displayName}</h4>
                        <div class="threshold-toggle-row">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="threshold-${sensorId}-enable"> Enable Alerts
                            </label>
                        </div>
                        <div class="threshold-toggle-row">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="threshold-${sensorId}-repeat"> Repeat Alerts (every 5 min)
                            </label>
                        </div>
                        <div class="threshold-input">
                            <label>Min (cm):</label>
                            <input type="number" id="threshold-${sensorId}-min" placeholder="e.g., 50" min="0">
                        </div>
                        <div class="threshold-input">
                            <label>Max (cm):</label>
                            <input type="number" id="threshold-${sensorId}-max" placeholder="e.g., 180" min="0">
                        </div>
                    </div>
                `;
            });
            */

            // Start fetching data
            updateAllData();
            setInterval(updateAllData, 20000); // Update every 20 seconds

            // Initialize charts
            google.charts.load('current', {'packages':['corechart']});
            google.charts.setOnLoadCallback(initializeCharts);
        }

        function changeLanguage(lang) {
            translationManager.setLanguage(lang);
            localStorage.setItem('preferredLanguage', lang);
        }

        document.addEventListener('DOMContentLoaded', function() {
            const savedLanguage = localStorage.getItem('preferredLanguage') || 'en';
            if (document.getElementById('language-select')) {
                document.getElementById('language-select').value = savedLanguage;
            }
            translationManager.setLanguage(savedLanguage);
        });

        function goBack() {
            window.location.href = 'index.html';
        }

        function timeAgo(timestamp) {
            const now = new Date();
            const past = new Date(timestamp);
            const diffMs = now - past;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} min ago`;
            return `${diffHours} hour(s) ago`;
        }

        function cmToFeetInches(cm) {
            const inches = cm / 2.54;
            const feet = Math.floor(inches / 12);
            const remainingInches = Math.round(inches % 12);
            return `${feet} ft ${remainingInches} in`;
        }

        function updateIndicator(sensor, value) {
            const indicator = document.getElementById(sensor + '_indicator');
            if (!indicator) return;
            const limits = currentPageConfig.sensors[sensor].limits;
            if (!limits) return;
            if (value <= limits.danger) {
                indicator.style.background = 'red';
            } else if (value <= limits.warning) {
                indicator.style.background = 'yellow';
            } else {
                indicator.style.background = 'green';
            }
        }

        /* ====================================================================
           PUSH NOTIFICATIONS - TEMPORARILY DISABLED
           ====================================================================
           REASON: Notification system disabled for testing/refinement
           
           COMMENTED CODE:
           - showNotification() function (lines 533-544)
           - Displays browser notifications with custom icons and options
           - Only shows if notifications are enabled in localStorage and browser supports them
           
           USAGE (when re-enabling):
           1. Uncomment showNotification() function below
           2. Uncomment calls to showNotification() in:
              - saveThresholdSettings() (line 655)
              - checkWaterLevelThresholds() (line 697)
           3. Ensure browser has notification permission granted
           ====================================================================== */
        
        /*
        // ✅ Show Notification
        function showNotification(title, options = {}) {
            if (localStorage.getItem('notificationsEnabled') === 'true' && 'Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification(title, {
                        icon: 'IIT_Madras_Logo_192.png',
                        badge: 'IIT_Madras_Logo.ico',
                        ...options
                    });
                }
            }
        }
        */

        // ✅ PAGE CONFIGURATION
        const pageConfig = {
            pageName: currentPageId,
            displayName: currentPageConfig.displayName,
            sensors: Object.keys(currentPageConfig.sensors)
        };

        /* ====================================================================
           ALERT SETTINGS BACKEND FUNCTIONS - ALL DISABLED
           ====================================================================
           REASON: Backend threshold checking system disabled globally
           
           DISABLED FUNCTIONS:
           - getGlobalAlertSettings() - Retrieves alert settings from localStorage
           - saveGlobalAlertSettings() - Saves alert settings to localStorage
           - checkWaterLevelThresholds() - Checks if water level breaches thresholds
           
           DISABLED CALLS:
           - checkWaterLevelThresholds() call in fetchThingSpeakData()
           
           DATA STORAGE:
           ✅ localStorage.setItem('globalAlertSettings') - Still works but unused
           ✅ localStorage.getItem('globalAlertSettings') - Retrievable but unused
           ✅ lastAlert_* timestamps - Still tracked but unused
           
           WHEN RE-ENABLING:
           1. Uncomment all 3 functions below
           2. Uncomment checkWaterLevelThresholds() call in fetchThingSpeakData()
           3. Uncomment getGlobalAlertSettings() helper calls
           4. Test threshold detection with configured limits
           ====================================================================== */
        
        /*
        // ✅ Get Global Alert Settings
        function getGlobalAlertSettings() {
            const defaults = {
                enabledAlerts: {},
                enabledRepeating: {},
                thresholds: {}
            };

            pageConfig.sensors.forEach(sensor => {
                defaults.enabledAlerts[sensor] = true;
                defaults.enabledRepeating[sensor] = false;
                defaults.thresholds[sensor] = { min: null, max: null };
            });

            const saved = localStorage.getItem('globalAlertSettings');
            if (!saved) return defaults;

            try {
                const parsed = JSON.parse(saved);
                return {
                    enabledAlerts: { ...defaults.enabledAlerts, ...parsed.enabledAlerts },
                    enabledRepeating: { ...defaults.enabledRepeating, ...parsed.enabledRepeating },
                    thresholds: { ...defaults.thresholds, ...parsed.thresholds }
                };
            } catch (e) {
                console.error('Error parsing alert settings:', e);
                return defaults;
            }
        }

        // ✅ Save Global Alert Settings
        function saveGlobalAlertSettings(settings) {
            try {
                localStorage.setItem('globalAlertSettings', JSON.stringify(settings));
            } catch (e) {
                console.error('Error saving alert settings:', e);
                alert('Error saving settings: ' + e.message);
            }
        }
        */

        /* ====================================================================
           THRESHOLD SETTINGS FUNCTIONS - ALL DISABLED
           ====================================================================
           REASON: Threshold settings UI removed from frontend
           
           DISABLED FUNCTIONS:
           - openThresholdSettings() - Opens modal dialog
           - closeThresholdSettings() - Closes modal dialog
           - loadThresholdSettings() - Loads saved thresholds from localStorage
           - saveThresholdSettings() - Saves threshold settings to localStorage
           
           BACKEND FUNCTIONALITY:
           ✅ STILL ACTIVE: checkWaterLevelThresholds() in fetchThingSpeakData()
           ✅ STILL ACTIVE: Threshold detection and cooldown logic
           ✅ STILL ACTIVE: localStorage storage of threshold settings
           
           WHEN RE-ENABLING:
           1. Uncomment these function definitions
           2. Uncomment threshold modal HTML (lines 330-340)
           3. Uncomment Alert Settings button (line 327)
           4. Uncomment sensorsContainer generation in initializePage()
           5. Test threshold modal opens/closes
           ====================================================================== */
        
        /*
        // ✅ Open Threshold Settings Modal
        function openThresholdSettings() {
            document.getElementById('thresholdSettings').classList.add('active');
            document.getElementById('thresholdOverlay').classList.add('active');
            loadThresholdSettings();
        }

        // ✅ Close Threshold Settings Modal
        function closeThresholdSettings() {
            document.getElementById('thresholdSettings').classList.remove('active');
            document.getElementById('thresholdOverlay').classList.remove('active');
        }

        // ✅ Load Threshold Settings
        function loadThresholdSettings() {
            const settings = getGlobalAlertSettings();

            pageConfig.sensors.forEach(sensor => {
                const minInput = document.getElementById(`threshold-${sensor}-min`);
                const maxInput = document.getElementById(`threshold-${sensor}-max`);
                const enableToggle = document.getElementById(`threshold-${sensor}-enable`);
                const repeatToggle = document.getElementById(`threshold-${sensor}-repeat`);

                if (minInput && settings.thresholds[sensor]) {
                    minInput.value = settings.thresholds[sensor].min || '';
                }
                if (maxInput && settings.thresholds[sensor]) {
                    maxInput.value = settings.thresholds[sensor].max || '';
                }
                if (enableToggle) {
                    enableToggle.checked = settings.enabledAlerts[sensor] !== false;
                }
                if (repeatToggle) {
                    repeatToggle.checked = settings.enabledRepeating[sensor] === true;
                }
            });
        }

        // ✅ Save Threshold Settings
        function saveThresholdSettings() {
            try {
                const settings = getGlobalAlertSettings();

                pageConfig.sensors.forEach(sensor => {
                    const minInput = document.getElementById(`threshold-${sensor}-min`);
                    const maxInput = document.getElementById(`threshold-${sensor}-max`);
                    const enableToggle = document.getElementById(`threshold-${sensor}-enable`);
                    const repeatToggle = document.getElementById(`threshold-${sensor}-repeat`);

                    settings.thresholds[sensor] = {
                        min: minInput && minInput.value ? parseFloat(minInput.value) : null,
                        max: maxInput && maxInput.value ? parseFloat(maxInput.value) : null
                    };

                    if (enableToggle) {
                        settings.enabledAlerts[sensor] = enableToggle.checked;
                    }
                    if (repeatToggle) {
                        settings.enabledRepeating[sensor] = repeatToggle.checked;
                    }
                });

                saveGlobalAlertSettings(settings);
                // NOTIFICATION DISABLED: showNotification('✅ Alert Settings Saved', {
                //     body: 'Your threshold settings have been saved globally.'
                // });
                alert('✅ Alert Settings Saved');
                closeThresholdSettings();
            } catch (e) {
                alert('Error saving thresholds: ' + e.message);
            }
        }
        */

        // ✅ Check Water Level Thresholds
        function checkWaterLevelThresholds(sensorId, currentLevel) {
            try {
                const settings = getGlobalAlertSettings();

                if (!settings.enabledAlerts[sensorId]) return;
                if (!settings.thresholds[sensorId]) return;

                const sensorThreshold = settings.thresholds[sensorId];
                const lastAlertKey = `lastAlert_${sensorId}`;
                const lastAlertTime = localStorage.getItem(lastAlertKey) || 0;
                const now = Date.now();

                const isRepeatingEnabled = settings.enabledRepeating[sensorId];
                const cooldownTime = isRepeatingEnabled ? 300000 : Infinity;

                if (now - parseInt(lastAlertTime) < cooldownTime) return;

                let shouldAlert = false;
                let alertMessage = '';
                let alertTitle = '';

                if (sensorThreshold.min !== null && currentLevel < sensorThreshold.min) {
                    shouldAlert = true;
                    alertTitle = `⚠️ ${sensorId} CRITICAL LOW`;
                    alertMessage = `Water level ${currentLevel} cm is below minimum ${sensorThreshold.min} cm`;
                } else if (sensorThreshold.max !== null && currentLevel > sensorThreshold.max) {
                    shouldAlert = true;
                    alertTitle = `⚠️ ${sensorId} CRITICAL HIGH`;
                    alertMessage = `Water level ${currentLevel} cm exceeds maximum ${sensorThreshold.max} cm`;
                }

                if (shouldAlert) {
                    // NOTIFICATION DISABLED: showNotification(alertTitle, { body: alertMessage });
                    console.warn('⚠️ Threshold breach detected - Notifications disabled:', { alertTitle, alertMessage });
                    localStorage.setItem(lastAlertKey, now.toString());
                }
            } catch (e) {
                console.error('Error checking thresholds:', e);
            }
        }

        // ✅ Fetch Data from ThingSpeak
        async function fetchThingSpeakData(sensorId) {
            const sensorConfig = currentPageConfig.sensors[sensorId];
            if (!sensorConfig) return;

            const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&results=20`;
            try {
                const response = await fetch(url, { method: 'GET', cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                if (!data || !data.feeds || data.feeds.length === 0) return;

                let lastValidValue = '--';
                let lastUpdated = 'No updates';
                for (let i = data.feeds.length - 1; i >= 0; i--) {
                    let rawValue = data.feeds[i][sensorConfig.field];
                    if (rawValue === null || rawValue === undefined || rawValue === '') continue;
                    let value = parseFloat(rawValue);
                    if (!isNaN(value)) {
                        lastValidValue = value;
                        lastUpdated = data.feeds[i].created_at;
                        break;
                    }
                }

                if (lastValidValue !== '--') {
                    const formattedValue = sensorConfig.isInteger ? Math.round(lastValidValue) : parseFloat(lastValidValue).toFixed(2);
                    const cmElement = document.getElementById(sensorId + '_cm');
                    const feetElement = document.getElementById(sensorId + '_feet');
                    const timeElement = document.getElementById(sensorId + '_time');

                    if (cmElement) cmElement.innerText = `${formattedValue} cm`;
                    if (feetElement) feetElement.innerText = cmToFeetInches(formattedValue);
                    if (timeElement) timeElement.innerText = 'Updated ' + timeAgo(lastUpdated);

                    updateIndicator(sensorId, formattedValue);
                    const numericValue = parseFloat(formattedValue);
                    // THRESHOLD CHECKING DISABLED: checkWaterLevelThresholds(sensorId, numericValue);
                    console.log(`[DATA] ${sensorId}: ${numericValue} cm (threshold checking disabled)`);
                }
            } catch (error) {
                console.error(`Error fetching data for ${sensorId}:`, error);
            }
        }

        function updateAllData() {
            Object.keys(currentPageConfig.sensors).forEach(sensor => fetchThingSpeakData(sensor));
        }

        // ✅ Initialize Charts
        let Chart;
        let ChartData;
        let isCustomRange = false;

        function initializeCharts() {
            ChartData = new google.visualization.DataTable();
            ChartData.addColumn('datetime', 'Time');
            ChartData.addColumn('number', 'Water Level (cm)');
            ChartData.addColumn({type: 'string', role: 'tooltip'});

            Chart = new google.visualization.LineChart(document.getElementById('level_chart'));
            
            // Setup date selector event listener
            document.getElementById('days-selector').addEventListener('change', function() {
                if (this.value === 'custom') {
                    document.getElementById('custom-range-section').style.display = 'block';
                    const savedCustomRange = localStorage.getItem('customDateRange');
                    if (savedCustomRange) {
                        const ranges = JSON.parse(savedCustomRange);
                        document.getElementById('custom-start-date').value = ranges.start;
                        document.getElementById('custom-end-date').value = ranges.end;
                        fetchCustomDateRange();
                    }
                } else {
                    document.getElementById('custom-range-section').style.display = 'none';
                    isCustomRange = false;
                    localStorage.removeItem('customDateRange');
                    fetchHistoricalData();
                }
            });
            
            // Setup color picker event listener
            const colorPicker = document.getElementById('line-color-picker');
            if (colorPicker) {
                colorPicker.addEventListener('change', function() {
                    localStorage.setItem('graphLineColor', this.value);
                    if (isCustomRange) {
                        fetchCustomDateRange();
                    } else {
                        fetchHistoricalData();
                    }
                });
            }
            
            // Check if custom date range was saved
            const savedCustomRange = localStorage.getItem('customDateRange');
            if (savedCustomRange) {
                const ranges = JSON.parse(savedCustomRange);
                document.getElementById('custom-start-date').value = ranges.start;
                document.getElementById('custom-end-date').value = ranges.end;
                document.getElementById('days-selector').value = 'custom';
                document.getElementById('custom-range-section').style.display = 'block';
                isCustomRange = true;
                fetchCustomDateRange();
            } else {
                fetchHistoricalData();
            }
        }
        
        function getResponsiveChartOptions(title, selectedDays = 1) {
            const isMobile = window.innerWidth <= 768;
            const dayText = selectedDays === 1 ? 'Day' : 'Days';
            const lineColor = localStorage.getItem('graphLineColor') || '#048ebd';
            
            return {
                title: title,
                titleTextStyle: { color: '#333', fontSize: isMobile ? 12 : 14, bold: true },
                legend: { position: 'bottom' },
                hAxis: { title: 'Time', format: selectedDays === 1 ? 'HH:mm' : 'dd/MM HH:mm', gridlines: { count: isMobile ? 4 : 8 }, titleTextStyle: { fontSize: isMobile ? 10 : 12 }, textStyle: { fontSize: isMobile ? 9 : 11 } },
                vAxis: { title: 'Water Level (cm)', minValue: 0, titleTextStyle: { fontSize: isMobile ? 10 : 12 }, textStyle: { fontSize: isMobile ? 9 : 11 } },
                colors: [lineColor],
                lineWidth: 3,
                pointSize: 5,
                chartArea: isMobile ? { left: 40, top: 30, width: '92%', height: '70%' } : { left: 50, top: 35, width: '95%', height: '75%' },
                animation: { duration: 1000, easing: 'out' }
            };
        }

        async function fetchHistoricalData() {
            try {
                // Get first sensor for historical data
                const firstSensor = Object.keys(currentPageConfig.sensors)[0];
                const sensorConfig = currentPageConfig.sensors[firstSensor];
                const selectedDays = parseInt(document.getElementById('days-selector').value) || 1;
                
                const endDate = new Date();
                const startDate = new Date(endDate.getTime() - (selectedDays * 24 * 60 * 60 * 1000));
                
                const startStr = `${startDate.getUTCFullYear()}-${(startDate.getUTCMonth()+1).toString().padStart(2, '0')}-${startDate.getUTCDate().toString().padStart(2, '0')}%20${startDate.getUTCHours().toString().padStart(2, '0')}:${startDate.getUTCMinutes().toString().padStart(2, '0')}:${startDate.getUTCSeconds().toString().padStart(2, '0')}`;
                const endStr = `${endDate.getUTCFullYear()}-${(endDate.getUTCMonth()+1).toString().padStart(2, '0')}-${endDate.getUTCDate().toString().padStart(2, '0')}%20${endDate.getUTCHours().toString().padStart(2, '0')}:${endDate.getUTCMinutes().toString().padStart(2, '0')}:${endDate.getUTCSeconds().toString().padStart(2, '0')}`;
                
                const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000`;
                
                const response = await fetch(url, { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                
                if (!data || !data.feeds || data.feeds.length === 0) {
                    const dayText = selectedDays === 1 ? 'Day' : 'Days';
                    document.getElementById('chart_update_time').innerText = `No data available in the last ${selectedDays} ${dayText}. Data collection may have started recently.`;
                    ChartData.removeRows(0, ChartData.getNumberOfRows());
                    Chart.draw(ChartData, getResponsiveChartOptions(`${currentPageConfig.displayName} - Water Level History (${selectedDays} ${dayText}) - No Data`, selectedDays));
                    return;
                }
                
                const dayText = selectedDays === 1 ? 'Day' : 'Days';
                const Rows = [];
                
                data.feeds.forEach(feed => {
                    const date = new Date(feed.created_at);
                    const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                    if (Value !== null) {
                        const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                        Rows.push([date, Value, Tooltip]);
                    }
                });
                
                ChartData.removeRows(0, ChartData.getNumberOfRows());
                ChartData.addRows(Rows);
                
                const Options = getResponsiveChartOptions(`${currentPageConfig.displayName} - Water Level History (${selectedDays} ${dayText})`, selectedDays);
                Chart.draw(ChartData, Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById('chart_update_time').innerText = `Chart updated: ${currentTime} • ${Rows.length} data points • ${selectedDays} ${dayText}`;
                    
            } catch (error) {
                console.error("Error fetching historical data:", error);
                document.getElementById('chart_update_time').innerText = `Error loading chart data: ${error.message}`;
            }
        }
        
        // Fetch data for custom date range (handles 8000 point limit by making multiple calls)
        async function fetchCustomDateRange() {
            const startInput = document.getElementById('custom-start-date').value;
            const endInput = document.getElementById('custom-end-date').value;
            
            if (!startInput || !endInput) {
                alert('Please select both start and end dates');
                return;
            }
            
            try {
                document.getElementById('chart_update_time').innerText = 'Fetching data for custom range...';
                
                const firstSensor = Object.keys(currentPageConfig.sensors)[0];
                const sensorConfig = currentPageConfig.sensors[firstSensor];
                const startDate = new Date(startInput);
                const endDate = new Date(endInput);
                
                if (startDate >= endDate) {
                    alert('Start date must be before end date');
                    return;
                }
                
                let allRows = [];
                let currentStart = new Date(startDate);
                
                // Fetch data in chunks to handle 8000 point limit
                while (currentStart < endDate) {
                    // Calculate chunk end (7 days at a time to stay under 8000 points)
                    const chunkEnd = new Date(currentStart.getTime() + (7 * 24 * 60 * 60 * 1000));
                    const actualEnd = chunkEnd < endDate ? chunkEnd : endDate;
                    
                    const startStr = `${currentStart.getUTCFullYear()}-${(currentStart.getUTCMonth()+1).toString().padStart(2, '0')}-${currentStart.getUTCDate().toString().padStart(2, '0')}%20${currentStart.getUTCHours().toString().padStart(2, '0')}:${currentStart.getUTCMinutes().toString().padStart(2, '0')}:${currentStart.getUTCSeconds().toString().padStart(2, '0')}`;
                    const endStr = `${actualEnd.getUTCFullYear()}-${(actualEnd.getUTCMonth()+1).toString().padStart(2, '0')}-${actualEnd.getUTCDate().toString().padStart(2, '0')}%20${actualEnd.getUTCHours().toString().padStart(2, '0')}:${actualEnd.getUTCMinutes().toString().padStart(2, '0')}:${actualEnd.getUTCSeconds().toString().padStart(2, '0')}`;
                    
                    const url = `https://api.thingspeak.com/channels/${sensorConfig.channelID}/feeds.json?api_key=${sensorConfig.apiKey}&start=${startStr}&end=${endStr}&results=8000`;
                    
                    console.log(`Fetching chunk from ${startStr} to ${endStr}`);
                    const response = await fetch(url, { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    
                    const data = await response.json();
                    
                    if (data && data.feeds && data.feeds.length > 0) {
                        data.feeds.forEach(feed => {
                            const date = new Date(feed.created_at);
                            const Value = feed[sensorConfig.field] ? parseFloat(feed[sensorConfig.field]) : null;
                            if (Value !== null) {
                                const Tooltip = `${date.toLocaleDateString()} ${date.toLocaleTimeString()} - Level: ${Math.round(Value)} cm`;
                                allRows.push([date, Value, Tooltip]);
                            }
                        });
                    }
                    
                    currentStart = new Date(actualEnd.getTime() + 1000); // Move to next chunk
                }
                
                // Remove duplicates and sort by date
                const uniqueRows = Array.from(new Set(allRows.map(r => r[0].getTime())))
                    .map(time => allRows.find(r => r[0].getTime() === time))
                    .sort((a, b) => a[0] - b[0]);
                
                if (uniqueRows.length === 0) {
                    document.getElementById('chart_update_time').innerText = 'No data found for the selected date range';
                    return;
                }
                
                // Save custom range to localStorage
                localStorage.setItem('customDateRange', JSON.stringify({
                    start: startInput,
                    end: endInput
                }));
                isCustomRange = true;
                
                // Update Chart
                ChartData.removeRows(0, ChartData.getNumberOfRows());
                ChartData.addRows(uniqueRows);
                
                const Options = getResponsiveChartOptions(`${currentPageConfig.displayName} - Water Level History (Custom Range)`, 1);
                Chart.draw(ChartData, Options);
                
                const currentTime = new Date().toLocaleTimeString();
                document.getElementById('chart_update_time').innerText = 
                    `Chart updated: ${currentTime} • ${uniqueRows.length} data points • Custom range: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`;
                    
            } catch (error) {
                console.error("Error fetching custom date range:", error);
                document.getElementById('chart_update_time').innerText = `Error: ${error.message}`;
            }
        }
    </script>
</body>
</html>

